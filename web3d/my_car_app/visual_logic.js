/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.8.0
 * Wed, 19 Feb 2025 07:47:44 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();
_pGlob.materialsCache = new Map();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    const transformEulerV3dToBlenderShortest = function() {
        const eulerTmp = new v3d.Euler();
        const eulerTmp2 = new v3d.Euler();
        const vec3Tmp = new v3d.Vector3();
    
        return function(euler, dest) {
            const eulerBlender = eulerTmp.copy(euler).reorder('YZX');
            const eulerBlenderAlt = eulerTmp2.copy(eulerBlender).makeAlternative();
    
            const len = vec3Tmp.setFromEuler(eulerBlender).lengthSq();
            const lenAlt = vec3Tmp.setFromEuler(eulerBlenderAlt).lengthSq();
    
            dest.copy(len < lenAlt ? eulerBlender : eulerBlenderAlt);
            return transformCoordsSpace(dest, 'Y_UP_RIGHT', 'Z_UP_RIGHT');
        }
    }();
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }
        
    function RotationInterface() {
        /**
         * @ignore
         * For user manipulations use XYZ extrinsic rotations (which
         * are the same as ZYX intrinsic rotations)
         *     - Blender/Max/Maya use extrinsic rotations in the UI
         *     - XYZ is the default option, but could be set from
         *       some order hint if exported
         */
        this._userRotation = new v3d.Euler(0, 0, 0, 'ZYX');
        this._actualRotation = new v3d.Euler();
    }
    
    Object.assign(RotationInterface, {
        initObject: function(obj) {
            if (obj.userData.puzzles === undefined) {
                obj.userData.puzzles = {}
            }
            if (obj.userData.puzzles.rotationInterface === undefined) {
                obj.userData.puzzles.rotationInterface = new RotationInterface();
            }
    
            const rotUI = obj.userData.puzzles.rotationInterface;
            rotUI.updateFromObject(obj);
            return rotUI;
        },
    });
    
    Object.assign(RotationInterface.prototype, {
        updateFromObject: function(obj) {
            const SYNC_ROT_EPS = 1e-8;
    
            if (!this._actualRotation.equalsEps(obj.rotation, SYNC_ROT_EPS)) {
                this._actualRotation.copy(obj.rotation);
                this._updateUserRotFromActualRot();
            }
        },
    
        getActualRotation: function(euler) {
            return euler.copy(this._actualRotation);
        },
    
        setUserRotation: function(euler) {
            // don't copy the order, since it's fixed to ZYX for now
            this._userRotation.set(euler.x, euler.y, euler.z);
            this._updateActualRotFromUserRot();
        },
    
        getUserRotation: function(euler) {
            return euler.copy(this._userRotation);
        },
    
        _updateUserRotFromActualRot: function() {
            const order = this._userRotation.order;
            this._userRotation.copy(this._actualRotation).reorder(order);
        },
    
        _updateActualRotFromUserRot: function() {
            const order = this._actualRotation.order;
            this._actualRotation.copy(this._userRotation).reorder(order);
        },
    });
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getEventOffsetCoords(event, touchId, dest) {
        if (event instanceof MouseEvent) {
            dest.set(event.offsetX, event.offsetY);
        } else if (window.TouchEvent && event instanceof TouchEvent) {
            const rect = event.target.getBoundingClientRect();
            let touches = event.touches;
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                touches = event.changedTouches;
            }
    
            let touch = touches[0];
            for (let i = 0; i < touches.length; i++) {
                if (touches[i].identifier === touchId) {
                    touch = touches[i];
                    break;
                }
            }
    
            dest.set(touch.clientX - rect.left, touch.clientY - rect.top);
        }
        return dest;
    }
        
    function isChangedTouchOrNotTouchEventAtAll(event, touchId) {
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                let isChanged = false;
                for (let i = 0; i < event.changedTouches.length; i++) {
                    if (event.changedTouches[i].identifier === touchId) {
                        isChanged = true;
                        break;
                    }
                }
                return isChanged;
            }
        }
    
        return true;
    }
        
    function getEventFirstTouchId(event) {
        if (window.TouchEvent && event instanceof TouchEvent) {
            if (event.type === 'touchstart' || event.type === 'touchend'
                    || event.type === 'touchmove') {
                return event.changedTouches[0].identifier;
            } else {
                return event.touches[0].identifier;
            }
        }
        return -1;
    }
        
    function createDragOverInfo() {
        return {
            draggedObjName: '',
            downX: 0, downY: 0,
            prevX: 0, prevY: 0,
            currX: 0, currY: 0,
            isDowned: false,
            isMoved: false,
            touchId: -1,
            downPointWorld: new v3d.Vector3(),
        };
    }
        
    function unbindListener(target, type, listener, optionsOrUseCapture) {
        const index = _pGlob.eventListeners.findIndex(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                elem.optionsOrUseCapture, target, type, listener,
                optionsOrUseCapture);
        });
    
        if (index !== -1) {
            target.removeEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.splice(index, 1);
        }
    }

    return {
        transformCoordsSpace, transformEulerV3dToBlenderShortest, getSceneCoordSystem, getObjectByName,
        retrieveObjectNames, RotationInterface, getObjectName, initObjectPicking,
        isObjectAmongObjects, bindListener, getEventOffsetCoords, isChangedTouchOrNotTouchEventAtAll,
        getEventFirstTouchId, createDragOverInfo, unbindListener,
    };
};

var PL = {};



// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}



var light;

// setObjTransform puzzle
function setObjTransform(objSelector, isWorldSpace, mode, vector, offset){
    var x = vector[0];
      var y = vector[1];
      var z = vector[2];

    var objNames = PzLib.retrieveObjectNames(objSelector);

    function setObjProp(obj, prop, val) {
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inputsUsed = _pGlob.vec3Tmp.set(Number(x !== ''), Number(y !== ''),
            Number(z !== ''));
    var coords = _pGlob.vec3Tmp2.set(x || 0, y || 0, z || 0);

    if (mode === 'rotation') {
        // rotations are specified in degrees
        coords.multiplyScalar(v3d.MathUtils.DEG2RAD);
    }

    var coordSystem = PzLib.getSceneCoordSystem();

    PzLib.transformCoordsSpace(inputsUsed, coordSystem, 'Y_UP_RIGHT', true);
    PzLib.transformCoordsSpace(coords, coordSystem, 'Y_UP_RIGHT', mode === 'scale');

    for (var i = 0; i < objNames.length; i++) {

        var objName = objNames[i];
        if (!objName) continue;

        var obj = PzLib.getObjectByName(objName);
        if (!obj) continue;

        if (isWorldSpace && obj.parent) {
            obj.matrixWorld.decomposeE(obj.position, obj.rotation, obj.scale);

            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

            obj.matrixWorld.composeE(obj.position, obj.rotation, obj.scale);
            obj.matrix.multiplyMatrices(_pGlob.mat4Tmp.copy(obj.parent.matrixWorld).invert(), obj.matrixWorld);
            obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);

        } else if (mode === 'rotation' && coordSystem == 'Z_UP_RIGHT') {
            // Blender/Max coordinates

            // need all the rotations for order conversions, especially if some
            // inputs are not specified
            var euler = PzLib.transformEulerV3dToBlenderShortest(obj.rotation,
                    _pGlob.eulerTmp);
            PzLib.transformCoordsSpace(euler, coordSystem, 'Y_UP_RIGHT');

            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            /**
             * convert from Blender/Max default XYZ extrinsic order to v3d XYZ
             * intrinsic with reversion (XYZ -> ZYX) and axes swizzling (ZYX -> YZX)
             */
            euler.order = "YZX";
            euler.reorder(obj.rotation.order);
            obj.rotation.copy(euler);

        } else if (mode === 'rotation' && coordSystem == 'Y_UP_RIGHT') {
            // Maya coordinates

            // Use separate rotation interface to fix ambiguous rotations for Maya,
            // might as well do the same for Blender/Max.

            var rotUI = PzLib.RotationInterface.initObject(obj);
            var euler = rotUI.getUserRotation(_pGlob.eulerTmp);
            // TODO(ivan): this probably needs some reasonable wrapping
            if (inputsUsed.x) euler.x = offset ? euler.x + coords.x : coords.x;
            if (inputsUsed.y) euler.y = offset ? euler.y + coords.y : coords.y;
            if (inputsUsed.z) euler.z = offset ? euler.z + coords.z : coords.z;

            rotUI.setUserRotation(euler);
            rotUI.getActualRotation(obj.rotation);
        } else {
            if (inputsUsed.x) setObjProp(obj, "x", coords.x);
            if (inputsUsed.y) setObjProp(obj, "y", coords.y);
            if (inputsUsed.z) setObjProp(obj, "z", coords.z);

        }

        obj.updateMatrixWorld(true);
    }

}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);
            var objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}

// dragRotateAdv puzzle
const dragRotateAdv = (() => {

    // Blender/Max right-handed -> Verge3D right-handed
    const Z_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Z,
        Z: _pGlob.AXIS_Y,
    });

    // Blender/Max right-handed -> Verge3D right-handed with a camera parent
    const Z_UP_RIGHT_CAM_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    // Maya right-handed -> Verge3D right-handed
    const Y_UP_RIGHT_COORDS = Object.freeze({
        X: _pGlob.AXIS_X,
        Y: _pGlob.AXIS_Y,
        Z: _pGlob.AXIS_Z,
    });

    const axisVec = new v3d.Vector3();
    const axisVecLocal = new v3d.Vector3();

    const objQuatWorld = new v3d.Quaternion();
    const objQuatWorldConj = new v3d.Quaternion();
    const parentQuatWorld = new v3d.Quaternion();

    const objPosWorld = new v3d.Vector3();
    const axisLineEndPoint = new v3d.Vector3();
    const axisLine = new v3d.Line3();
    const downPointProjOnLine = new v3d.Vector3();

    const rotationPoint = new v3d.Vector3();
    const vecPointerFrom = new v3d.Vector2();
    const vecPointerTo = new v3d.Vector2();

    const viewVec = new v3d.Vector3();

    const rotationQuat = new v3d.Quaternion();

    return (objSelector, mode, spaceType, blockId, parentDragOverBlockId) => {

        const camera = appInstance.getCamera(true);
        if (!camera) return;

        if (!_pGlob.objDragOverInfoByBlock) return;
        const info = _pGlob.objDragOverInfoByBlock[parentDragOverBlockId];
        if (!info) return;

        const appWidth = appInstance.getWidth();
        const appHeight = appInstance.getHeight();

        const isZupRight = PzLib.getSceneCoordSystem() === 'Z_UP_RIGHT';

        const objNames = PzLib.retrieveObjectNames(objSelector);

        for (let i = 0; i < objNames.length; i++) {
            const obj = PzLib.getObjectByName(objNames[i]);
            if (!obj) continue;

            obj.getWorldQuaternion(objQuatWorld);

            const needParentCamCoords = obj.parent && obj.parent.isCamera
                    && spaceType === 'PARENT';
            const coords = isZupRight
                    ? (needParentCamCoords ? Z_UP_RIGHT_CAM_COORDS : Z_UP_RIGHT_COORDS)
                    : Y_UP_RIGHT_COORDS;
            axisVec.copy(coords[mode]);
            if (spaceType === 'LOCAL') {
                axisVec.applyQuaternion(objQuatWorld);
            } else if (spaceType === 'PARENT') {
                obj.parent.getWorldQuaternion(parentQuatWorld);
                axisVec.applyQuaternion(parentQuatWorld);
            } else {
                // considered to be in the world space, no need for transforming
            }

            obj.getWorldPosition(objPosWorld);

            axisLineEndPoint.addVectors(objPosWorld, axisVec);
            axisLine.set(objPosWorld, axisLineEndPoint);
            axisLine.closestPointToPoint(info.downPointWorld, false, downPointProjOnLine);

            rotationPoint.copy(downPointProjOnLine);
            rotationPoint.project(camera);

            const rotX = (rotationPoint.x + 1) / 2 * appWidth;
            const rotY = (-rotationPoint.y + 1) / 2 * appHeight;

            vecPointerFrom.set(info.prevX - rotX, info.prevY - rotY);
            vecPointerTo.set(info.currX - rotX, info.currY - rotY);

            objQuatWorldConj.copy(objQuatWorld).conjugate();
            axisVecLocal.copy(axisVec).applyQuaternion(objQuatWorldConj).normalize();

            /**
             * Negated in order to keep the rotation direction consistent with
             * mouse movement after transforming coordinates from the NDC space
             * to the canvas space.
             */
            let rotAngle = -(vecPointerTo.angle() - vecPointerFrom.angle());

            /**
             * Negated if the rotation axis points outwards the camera. Not
             * needed and can have issues for objects parented to camera.
             */
            if (!needParentCamCoords) {
                camera.getWorldDirection(viewVec);
                if (viewVec.dot(axisVec) > 0) {
                    rotAngle = -rotAngle;
                }
            }

            rotationQuat.setFromAxisAngle(axisVecLocal, rotAngle);

            obj.quaternion.multiply(rotationQuat);
            obj.updateMatrixWorld(true);
        }
    };
})();

// whenDraggedOver puzzle
_pGlob.objDragOverInfoGlobal = [];
_pGlob.objDragOverInfoByBlock = {}

PzLib.initObjectPicking(function(intersects, downEvent) {

    _pGlob.objDragOverInfoGlobal.forEach(function(el) {

        if (downEvent instanceof MouseEvent)
            if (el.mouseButtons.indexOf(downEvent.button) == -1)
                return;

        var maxIntersects = el.xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);

            if (PzLib.isObjectAmongObjects(objName, [el.objName])) {
                el.callback({
                    downEvent: downEvent,
                    draggedObjName: objName,
                    downPointWorld: intersects[i].point,
                });
            }

        }

    });

}, 'mousedown', true);

// whenDraggedOver puzzle
function registerOnDrag(objSelector, xRay, mouseButtons, cbStart, cbMove, cbDrop, blockId) {

    var cb = function(cbParam) {

        if (appInstance.controls) {
            appInstance.controls.enabled = false;
        }

        if (!(blockId in _pGlob.objDragOverInfoByBlock)) {
            _pGlob.objDragOverInfoByBlock[blockId] = PzLib.createDragOverInfo();
        }
        var info = _pGlob.objDragOverInfoByBlock[blockId];

        // NOTE: don't use more than one pointing event, e.g. don't process
        // some events related to multitouch actions
        if (info.isDowned) {
            return;
        }

        var touchId = PzLib.getEventFirstTouchId(cbParam.downEvent);
        var coords = PzLib.getEventOffsetCoords(cbParam.downEvent, touchId,
                _pGlob.vec2Tmp);

        info.downX = info.prevX = info.currX = coords.x;
        info.downY = info.prevY = info.currY = coords.y;
        info.touchId = touchId;
        info.isDowned = true;
        info.isMoved = false;
        info.draggedObjName = cbParam.draggedObjName;
        info.downPointWorld.copy(cbParam.downPointWorld);

        cbStart(cbParam.downEvent);

        var elem = appInstance.container;

        var moveCb = function(e) {
            if (!PzLib.isChangedTouchOrNotTouchEventAtAll(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = PzLib.getEventOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.prevX = info.currX;
            info.prevY = info.currY;
            info.currX = coords.x;
            info.currY = coords.y;
            cbMove(e);
            info.isMoved = true;
        }
        var upCb = function(e) {
            if (!PzLib.isChangedTouchOrNotTouchEventAtAll(e, info.touchId)) {
                // don't handle events not intended for this particular touch
                return;
            }

            var coords = PzLib.getEventOffsetCoords(e, info.touchId, _pGlob.vec2Tmp);
            info.currX = coords.x;
            info.currY = coords.y;
            info.prevX = info.currX;
            info.prevY = info.currY;
            cbDrop(e);
            info.isDowned = false;

            PzLib.unbindListener(elem, 'mousemove', moveCb);
            PzLib.unbindListener(elem, 'touchmove', moveCb);
            PzLib.unbindListener(elem, 'mouseup', upCb);
            PzLib.unbindListener(elem, 'touchend', upCb);
            if (appInstance.controls) {
                appInstance.controls.enabled = true;
            }
        }

        PzLib.bindListener(elem, 'mousemove', moveCb);
        PzLib.bindListener(elem, 'touchmove', moveCb);
        PzLib.bindListener(elem, 'mouseup', upCb);
        PzLib.bindListener(elem, 'touchend', upCb);
    }

    var objNames = PzLib.retrieveObjectNames(objSelector);

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        _pGlob.objDragOverInfoGlobal.push({
            objName: objName,
            callback: cb,
            xRay: xRay,
            mouseButtons: mouseButtons
        });
    }
}

// setLightParam puzzle
function setLightParam(type, objSelector, param) {

    if (type === 'SHADOW_MAP_FILTERING') {
        const rendererShadowMap = appInstance.renderer.shadowMap;
        if (rendererShadowMap) {
            let shadowMapFilteringTypeBefore = rendererShadowMap.type;

            switch (param) {
                case 'BASIC':
                    rendererShadowMap.type = v3d.BasicShadowMap;
                    break;
                case 'BILINEAR':
                    rendererShadowMap.type = v3d.BilinearShadowMap;
                    break;
                case 'PCF':
                // COMPAT: deprecated, PCF == v3d.PCFShadowMapPoissonDisk since 4.7
                case 'PCFBILINEAR':
                case 'PCFPOISSON':
                    // TODO: PCF == v3d.PCFShadow since 4.8
                    rendererShadowMap.type = v3d.PCFShadowMapPoissonDisk;
                    break;
                case 'ESM':
                    rendererShadowMap.type = v3d.ESMShadowMap;
                    break;
                default:
                    console.error('setLightParam puzzle: Incompatible shadow map filtering type.')
                    return;
                    break;
            }

            if (shadowMapFilteringTypeBefore != rendererShadowMap.type) {

                let deleteShadowMapFromObj = function(object) {
                    if (!object.shadow) return;

                    if (object.shadow.isDirectionalLightShadowCSM) {
                        object.shadow.updateMaps();

                    } else if (object.shadow) {
                        object.shadow.dispose();
                        object.shadow.map = null;
                        object.shadow._additionalMap2D = null;
                        object.shadow._additionalMapCube = null;
                    }
                }

                // need to update shadow.map for ESM filtering
                let needToUpdateShadowMaps = shadowMapFilteringTypeBefore == v3d.ESMShadowMap ||
                        rendererShadowMap.type == v3d.ESMShadowMap;
                const compiled = {};
                appInstance.scene.traverse(function(object) {

                    const material = object.material;
                    if (material && object.receiveShadow) {

                        if (Array.isArray(material)) {
                            for (let i = 0; i < material.length; i++) {
                                const material2 = material[i];

                                if (material2.uuid in compiled === false) {
                                    material2.needsUpdate = true;
                                    compiled[material2.uuid] = true;
                                }

                            }

                        } else if (material.uuid in compiled === false) {
                            material.needsUpdate = true;
                            compiled[material.uuid] = true;

                        }
                    }

                    if (needToUpdateShadowMaps)
                        deleteShadowMapFromObj(object);
                });
            }

        }
        return;
    }

    const objNames = PzLib.retrieveObjectNames(objSelector);

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        const obj = PzLib.getObjectByName(objName);
        if (!obj || !obj.isLight)
            return;

        switch (type) {
        case 'COLOR_VECTOR':
            obj.color.r = param[0];
            obj.color.g = param[1];
            obj.color.b = param[2];
            break;
        case 'COLOR_CSS_HEX':
        case 'COLOR_CSS_RGB':
            const color = _pGlob.colorTmp.set(param);
            obj.color.r = color.r;
            obj.color.g = color.g;
            obj.color.b = color.b;
            break;
        case 'INTENSITY':
            if (obj.userData.usePowerUnits)
                obj.power = param;
            else
                obj.intensity = param;
            break;
        case 'USE_SHADOW':
            if (obj.isAmbientLight || obj.isHemisphereLight) {
                console.error('setLightParam puzzle: Incompatible light source');
                return;
            }
            if (typeof(param) === "boolean")
                obj.castShadow = param;

            break;
        case 'SHADOW_MAP_SIZE':
            if (obj.isAmbientLight || obj.isHemisphereLight) {
                console.error('setLightParam puzzle: Incompatible light source');
                return;
            }

            if (!obj.shadow) return;

            if (obj.shadow.isDirectionalLightShadowCSM) {
                obj.shadow.mapSize.set(param, param);
                obj.shadow.updateMapSize();

            } else if (obj.shadow) {
                obj.shadow.mapSize.set(param, param);
                obj.shadow.dispose();
                obj.shadow.map = null;
                obj.shadow._additionalMap2D = null;
                obj.shadow._additionalMapCube = null;
            }

            break;
        }

    });

}


light = true;
registerOnClick('左前门', false, false, [0,1,2], function() {
  setObjTransform('左前门', false, 'rotation', [0, 0, 0], false);
}, function() {});
registerOnClick('右前门', false, false, [0,1,2], function() {
  setObjTransform('右前门', false, 'rotation', [0, 0, 0], false);
}, function() {});
registerOnDrag('左前门', false, [0,1,2], function() {}, function() {
  dragRotateAdv('左前门', 'Z', 'WORLD', 'FqAu1$}[TIc)Tu[bB[ij', '~lP6{U@60!BYH8QP=m-3');
}, function() {}, '~lP6{U@60!BYH8QP=m-3');
registerOnDrag('右前门', false, [0,1,2], function() {}, function() {
  dragRotateAdv('右前门', 'Z', 'WORLD', 'CtRJcr/iO9hIU,0Q1w{N', '$cBy8~K*m*x=@Z:fo(zX');
}, function() {}, '$cBy8~K*m*x=@Z:fo(zX');
registerOnClick('圆环', false, false, [0,1,2], function() {
  if (light == false) {
    setLightParam('INTENSITY', '聚光', 100);
    setLightParam('INTENSITY', '聚光.001', 100);
    light = true;
  } else if (light == true) {
    setLightParam('INTENSITY', '聚光', 0);
    setLightParam('INTENSITY', '聚光.001', 0);
    light = false;
  }
}, function() {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.disposeMaterialsCache = function() {
    if (_pGlob) {
        for (const mat of _pGlob.materialsCache.values()) {
            mat.dispose();
        }
        _pGlob.materialsCache.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    PL.disposeMaterialsCache();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
